<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Melodic Performance Benchmark</title>
		<style>
			body {
				font-family: system-ui, -apple-system, sans-serif;
				max-width: 1200px;
				margin: 0 auto;
				padding: 20px;
			}
			.benchmark-section {
				margin: 20px 0;
				padding: 15px;
				border: 1px solid #ddd;
				border-radius: 8px;
			}
			.result {
				margin: 10px 0;
				padding: 10px;
				background: #f0f0f0;
				border-radius: 4px;
				font-family: monospace;
			}
			.result.pass {
				background: #d4edda;
			}
			.result.warn {
				background: #fff3cd;
			}
			button {
				padding: 10px 20px;
				margin: 5px;
				border: none;
				border-radius: 4px;
				background: #007bff;
				color: white;
				cursor: pointer;
			}
			button:hover {
				background: #0056b3;
			}
			#benchmark-container {
				min-height: 200px;
				border: 2px dashed #ccc;
				padding: 10px;
				margin: 10px 0;
			}
		</style>
	</head>
	<body>
		<h1>Melodic Framework Performance Benchmark</h1>

		<div class="benchmark-section" style="background: #e7f3ff; border-left: 4px solid #007bff">
			<h2>ğŸ“Š Framework Stats</h2>
			<p><strong>Bundle Size:</strong> 3.78 kB gzipped (11.55 kB minified)</p>
			<p><strong>Status:</strong> Smallest full-featured web component framework ğŸ†</p>
			<p><strong>Optimizations:</strong> Terser minification, tree-shaking, property mangling</p>
		</div>

		<div class="benchmark-section">
			<h2>Test Controls</h2>
			<button onclick="runAllBenchmarks()">Run All Benchmarks</button>
			<button onclick="clearResults()">Clear Results</button>
		</div>

		<div class="benchmark-section">
			<h2>Benchmark: Initial Render</h2>
			<p>Measures time to render 1000 items for the first time</p>
			<button onclick="benchmarkInitialRender()">Run Test</button>
			<div id="initial-render-result"></div>
		</div>

		<div class="benchmark-section">
			<h2>Benchmark: Update Performance</h2>
			<p>Measures time to update all 1000 items</p>
			<button onclick="benchmarkUpdate()">Run Test</button>
			<div id="update-result"></div>
		</div>

		<div class="benchmark-section">
			<h2>Benchmark: Partial Update</h2>
			<p>Measures time to update 10 items out of 1000</p>
			<button onclick="benchmarkPartialUpdate()">Run Test</button>
			<div id="partial-update-result"></div>
		</div>

		<div class="benchmark-section">
			<h2>Benchmark: List Reordering</h2>
			<p>Measures time to reverse/shuffle a list of 1000 items</p>
			<button onclick="benchmarkReordering()">Run Test</button>
			<div id="reordering-result"></div>
		</div>

		<div class="benchmark-section">
			<h2>Benchmark: Add/Remove Items</h2>
			<p>Measures time to add/remove items from a large list</p>
			<button onclick="benchmarkAddRemove()">Run Test</button>
			<div id="add-remove-result"></div>
		</div>

		<div id="benchmark-container"></div>

		<script type="module">
			import { html, render, repeat } from '../src/index.js';

			// Store benchmark results globally
			window.benchmarkResults = {
				initialRender: null,
				update: null,
				partialUpdate: null,
				reordering: null,
				addRemove: null
			};

			// Generate test data
			function generateItems(count) {
				return Array.from({ length: count }, (_, i) => ({
					id: i,
					text: `Item ${i}`,
					value: Math.random(),
					active: i % 2 === 0
				}));
			}

			// Benchmark: Initial Render
			window.benchmarkInitialRender = async function () {
				const container = document.getElementById('benchmark-container');
				const resultDiv = document.getElementById('initial-render-result');

				container.innerHTML = '';
				delete container.__parts;
				const items = generateItems(1000);

				const start = performance.now();

				const template = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li class="${item.active ? 'active' : ''}">${item.text}: ${item.value.toFixed(2)}</li>`
						)}
					</ul>
				`;

				render(template, container);

				const end = performance.now();
				const duration = end - start;

				window.benchmarkResults.initialRender = duration;

				const resultClass = duration < 40 ? 'pass' : duration < 80 ? 'warn' : '';
				resultDiv.innerHTML = `<div class="result ${resultClass}">
                Initial render of 1000 items: ${duration.toFixed(2)}ms
                <br>Target: &lt;40ms (excellent), &lt;80ms (good)
                <br><small>Optimized with terser, tree-shaking, and efficient directives</small>
            </div>`;
			};

			// Benchmark: Full Update
			window.benchmarkUpdate = async function () {
				const container = document.getElementById('benchmark-container');
				const resultDiv = document.getElementById('update-result');

				container.innerHTML = '';
				delete container.__parts;
				let items = generateItems(1000);

				// Initial render
				const initialTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li class="${item.active ? 'active' : ''}">${item.text}: ${item.value.toFixed(2)}</li>`
						)}
					</ul>
				`;
				render(initialTemplate, container);

				// Wait for render to complete
				await new Promise((resolve) => setTimeout(resolve, 0));

				// Update all items
				items = items.map((item) => ({
					...item,
					value: Math.random(),
					active: !item.active
				}));

				const start = performance.now();

				const updateTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li class="${item.active ? 'active' : ''}">${item.text}: ${item.value.toFixed(2)}</li>`
						)}
					</ul>
				`;

				render(updateTemplate, container);

				const end = performance.now();
				const duration = end - start;

				window.benchmarkResults.update = duration;

				const resultClass = duration < 25 ? 'pass' : duration < 50 ? 'warn' : '';
				resultDiv.innerHTML = `<div class="result ${resultClass}">
                Update 1000 items: ${duration.toFixed(2)}ms
                <br>Target: &lt;25ms (excellent), &lt;50ms (good)
                <br><small>Benefits from keyed list optimization in repeat directive</small>
            </div>`;
			};

			// Benchmark: Partial Update
			window.benchmarkPartialUpdate = async function () {
				const container = document.getElementById('benchmark-container');
				const resultDiv = document.getElementById('partial-update-result');

				container.innerHTML = '';
				delete container.__parts;
				let items = generateItems(1000);

				// Initial render
				const initialTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li class="${item.active ? 'active' : ''}">${item.text}: ${item.value.toFixed(2)}</li>`
						)}
					</ul>
				`;
				render(initialTemplate, container);

				await new Promise((resolve) => setTimeout(resolve, 0));

				// Update only 10 items
				items = items.map((item, i) => (i % 100 === 0 ? { ...item, value: Math.random(), active: !item.active } : item));

				const start = performance.now();

				const updateTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li class="${item.active ? 'active' : ''}">${item.text}: ${item.value.toFixed(2)}</li>`
						)}
					</ul>
				`;

				render(updateTemplate, container);

				const end = performance.now();
				const duration = end - start;

				window.benchmarkResults.partialUpdate = duration;

				const resultClass = duration < 8 ? 'pass' : duration < 15 ? 'warn' : '';
				resultDiv.innerHTML = `<div class="result ${resultClass}">
                Partial update (10 of 1000 items): ${duration.toFixed(2)}ms
                <br>Target: &lt;8ms (excellent), &lt;15ms (good)
                <br><small>Fast-path optimization skips unchanged items</small>
            </div>`;
			};

			// Benchmark: Reordering
			window.benchmarkReordering = async function () {
				const container = document.getElementById('benchmark-container');
				const resultDiv = document.getElementById('reordering-result');

				container.innerHTML = '';
				delete container.__parts;
				let items = generateItems(1000);

				// Initial render
				const initialTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li>${item.text}</li>`
						)}
					</ul>
				`;
				render(initialTemplate, container);

				await new Promise((resolve) => setTimeout(resolve, 0));

				// Reverse the list
				items = [...items].reverse();

				const start = performance.now();

				const updateTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li>${item.text}</li>`
						)}
					</ul>
				`;

				render(updateTemplate, container);

				const end = performance.now();
				const duration = end - start;

				window.benchmarkResults.reordering = duration;

				const resultClass = duration < 18 ? 'pass' : duration < 35 ? 'warn' : '';
				resultDiv.innerHTML = `<div class="result ${resultClass}">
                Reverse list of 1000 items: ${duration.toFixed(2)}ms
                <br>Target: &lt;18ms (excellent), &lt;35ms (good)
                <br><small>Efficient DOM reordering with keyed reconciliation</small>
            </div>`;
			};

			// Benchmark: Add/Remove
			window.benchmarkAddRemove = async function () {
				const container = document.getElementById('benchmark-container');
				const resultDiv = document.getElementById('add-remove-result');

				container.innerHTML = '';
				delete container.__parts;
				let items = generateItems(1000);

				// Initial render
				const initialTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li>${item.text}</li>`
						)}
					</ul>
				`;
				render(initialTemplate, container);

				await new Promise((resolve) => setTimeout(resolve, 0));

				// Remove 100 items and add 100 new items
				items = items.slice(100);
				const newItems = Array.from({ length: 100 }, (_, i) => ({
					id: 1000 + i,
					text: `New Item ${i}`,
					value: Math.random(),
					active: false
				}));
				items = [...items, ...newItems];

				const start = performance.now();

				const updateTemplate = html`
					<ul>
						${repeat(
							items,
							(item) => item.id,
							(item) => html`<li>${item.text}</li>`
						)}
					</ul>
				`;

				render(updateTemplate, container);

				const end = performance.now();
				const duration = end - start;

				window.benchmarkResults.addRemove = duration;

				const resultClass = duration < 22 ? 'pass' : duration < 45 ? 'warn' : '';
				resultDiv.innerHTML = `<div class="result ${resultClass}">
                Remove 100 and add 100 items: ${duration.toFixed(2)}ms
                <br>Target: &lt;22ms (excellent), &lt;45ms (good)
                <br><small>Smart reconciliation reuses DOM nodes when possible</small>
            </div>`;
			};

			// Run all benchmarks
			window.runAllBenchmarks = async function () {
				await benchmarkInitialRender();
				await new Promise((resolve) => setTimeout(resolve, 100));
				await benchmarkUpdate();
				await new Promise((resolve) => setTimeout(resolve, 100));
				await benchmarkPartialUpdate();
				await new Promise((resolve) => setTimeout(resolve, 100));
				await benchmarkReordering();
				await new Promise((resolve) => setTimeout(resolve, 100));
				await benchmarkAddRemove();

				// Summary
				console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
				console.log('â•‘       Melodic Performance Benchmark Results (v0.1)        â•‘');
				console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
				console.log('â•‘ Bundle Size: 2.82 kB gzipped     â•‘');
				console.log('â•‘ Status: Smallest full-featured web component framework    â•‘');
				console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
				console.log(`â•‘ Initial Render (1000 items):  ${(window.benchmarkResults.initialRender?.toFixed(2) || '').padEnd(6)} ms         â•‘`);
				console.log(`â•‘ Full Update (1000 items):     ${(window.benchmarkResults.update?.toFixed(2) || '').padEnd(6)} ms         â•‘`);
				console.log(`â•‘ Partial Update (10/1000):     ${(window.benchmarkResults.partialUpdate?.toFixed(2) || '').padEnd(6)} ms         â•‘`);
				console.log(`â•‘ Reordering (1000 items):      ${(window.benchmarkResults.reordering?.toFixed(2) || '').padEnd(6)} ms         â•‘`);
				console.log(`â•‘ Add/Remove (200 items):       ${(window.benchmarkResults.addRemove?.toFixed(2) || '').padEnd(6)} ms         â•‘`);
				console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
			};

			window.clearResults = function () {
				document.getElementById('initial-render-result').innerHTML = '';
				document.getElementById('update-result').innerHTML = '';
				document.getElementById('partial-update-result').innerHTML = '';
				document.getElementById('reordering-result').innerHTML = '';
				document.getElementById('add-remove-result').innerHTML = '';
				const container = document.getElementById('benchmark-container');
				container.innerHTML = '';
				delete container.__parts;
			};
		</script>
	</body>
</html>
