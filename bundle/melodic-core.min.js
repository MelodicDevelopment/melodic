const E = (n) => typeof n == "string" ? n : typeof n == "symbol" ? n.toString() : n.name;
function pt(n) {
  return function(e, t, r) {
    e.params || (e.params = []), e.params[r] = { __injectionToken: E(n) };
  };
}
function Q(n = {}) {
  return function(e) {
    const t = n.token ?? e, r = n.dependencies?.map((s) => E(s));
    P.bind(t, e, {
      singleton: n.singleton,
      dependencies: r,
      args: n.args
    });
  };
}
var F = class {
  constructor(n, e, t) {
    this._singleton = !0, this._dependencies = [], this._args = [], this._resolved = !1, this.key = n, this.token = e, this.type = t;
  }
  get isSingleton() {
    return this._singleton;
  }
  get isResolved() {
    return this._resolved;
  }
  get dependencies() {
    return this._dependencies;
  }
  get args() {
    return this._args;
  }
  get targetClass() {
    return this._class;
  }
  get factory() {
    return this._factory;
  }
  setClass(n) {
    return this._class = n, this;
  }
  setFactory(n) {
    return this._factory = n, this;
  }
  setSingleton(n) {
    return this._singleton = n, this;
  }
  withDependencies(n) {
    return this._dependencies = n.map((e) => E(e)), this;
  }
  withArgs(n) {
    return this._args = n, this;
  }
  getInstance() {
    return this._instance;
  }
  setInstance(n) {
    return this._instance = n, this._resolved = !0, this;
  }
  clearInstance() {
    return this._instance = void 0, this._resolved = !1, this;
  }
}, $e = class {
  constructor() {
    this._bindings = /* @__PURE__ */ new Map(), this._constructionStack = /* @__PURE__ */ new Set();
  }
  bind(n, e, t) {
    let r, s, o;
    typeof e == "function" ? (r = n, s = e, o = t) : (r = n, s = n, o = e);
    const i = E(r), a = new F(i, r, "class");
    return a.setClass(s), o?.singleton !== void 0 && a.setSingleton(o.singleton), o?.dependencies && a.withDependencies(o.dependencies), o?.args && a.withArgs(o.args), this._bindings.set(i, a), a;
  }
  bindValue(n, e) {
    const t = E(n), r = new F(t, n, "value");
    return r.setInstance(e), r.setSingleton(!0), this._bindings.set(t, r), r;
  }
  bindFactory(n, e, t) {
    const r = E(n), s = new F(r, n, "factory");
    return s.setFactory(e), t?.singleton !== void 0 && s.setSingleton(t.singleton), this._bindings.set(r, s), s;
  }
  get(n) {
    const e = E(n), t = this._bindings.get(e);
    if (!t) throw new Error(`Dependency could not be found: ${e}`);
    return this.resolve(t, e);
  }
  has(n) {
    const e = E(n);
    return this._bindings.has(e);
  }
  getBinding(n) {
    const e = E(n);
    return this._bindings.get(e);
  }
  unbind(n) {
    const e = E(n);
    return this._bindings.delete(e);
  }
  clear() {
    this._bindings.clear();
  }
  resolve(n, e) {
    if (n.type === "value") return n.getInstance();
    const t = n.getInstance();
    if (t !== void 0 && n.isSingleton) return t;
    if (this._constructionStack.has(e)) {
      const r = Array.from(this._constructionStack).join(" -> ") + ` -> ${e}`;
      throw new Error(`Circular dependency detected: ${r}`);
    }
    this._constructionStack.add(e);
    try {
      let r;
      return n.type === "factory" ? r = n.factory() : r = this.construct(n, e), n.isSingleton && n.setInstance(r), r;
    } finally {
      this._constructionStack.delete(e);
    }
  }
  construct(n, e) {
    const t = n.targetClass;
    let r = [];
    const s = t.params;
    if (s && Array.isArray(s)) for (let o = 0; o < s.length; o++) {
      const i = s[o];
      if (i && typeof i == "object" && i.__injectionToken) {
        const a = i.__injectionToken, c = this._bindings.get(a);
        if (!c) throw new Error(`Dependency '${a}' not found (required by '${e}')`);
        r.push(this.resolve(c, a));
      } else r.push(void 0);
    }
    else if (n.dependencies.length > 0) for (const o of n.dependencies) {
      const i = this._bindings.get(o);
      if (!i) throw new Error(`Dependency '${o}' not found (required by '${e}')`);
      r.push(this.resolve(i, o));
    }
    return n.args.length > 0 && (r = r.concat(n.args)), Reflect.construct(t, r);
  }
};
const P = new $e();
function T(n) {
  return function(e, t) {
    const r = `__service_${String(t)}`;
    e[r] = n, Object.defineProperty(e, t, {
      get() {
        const s = `__cached_${String(t)}`;
        return this[s] || (this[s] = P.get(n)), this[s];
      },
      enumerable: !0,
      configurable: !0
    });
  };
}
function j(n) {
  return Symbol(n);
}
async function mt(n = {}) {
  const e = n.devMode ?? !1, t = [];
  if (e && console.log("[Melodic] Bootstrap starting..."), n.onError) {
    const o = (a) => {
      n.onError(a.error, "error");
    }, i = (a) => {
      n.onError(a.reason, "unhandledrejection");
    };
    window.addEventListener("error", o), window.addEventListener("unhandledrejection", i), t.push({
      type: "error",
      handler: o
    }, {
      type: "unhandledrejection",
      handler: i
    });
  }
  if (n.onBefore && (e && console.log("[Melodic] Running onBefore hook..."), await n.onBefore()), n.providers) {
    for (const o of n.providers) o(P);
    e && console.log("[Melodic] Custom providers registered");
  }
  let r;
  if (n.rootComponent && n.target) {
    const o = typeof n.target == "string" ? document.querySelector(n.target) : n.target;
    if (!o) throw new Error(`[Melodic] Target element not found: ${n.target}`);
    if (!customElements.get(n.rootComponent)) throw new Error(`[Melodic] Component <${n.rootComponent}> is not registered. Make sure to import the component file before calling bootstrap().`);
    r = document.createElement(n.rootComponent), o.appendChild(r), e && console.log("[Melodic] Mounted root component", {
      component: n.rootComponent,
      target: n.target
    });
  }
  const s = {
    isDevMode: e,
    rootElement: r,
    get(o) {
      return P.get(o);
    },
    destroy() {
      for (const { type: o, handler: i } of t) window.removeEventListener(o, i);
      r?.parentNode && r.parentNode.removeChild(r), e && console.log("[Melodic] Application destroyed");
    }
  };
  return n.onReady && n.onReady(), e && console.log("[Melodic] Bootstrap complete"), P.bindValue("IMelodicApp", s), s;
}
function se(n, e) {
  n.renderInto(e);
}
const we = Symbol("melodic.signal"), Oe = (n) => typeof n == "function" && we in n;
var oe = "melodic-styles", De = `style[${oe}], link[rel="stylesheet"][${oe}]`, Z = [], K = null;
const qe = (n) => {
  if (je()) {
    ie(n);
    return;
  }
  K || (K = Le()), K.then(() => ie(n));
};
var Le = async () => {
  const n = document.querySelectorAll(De);
  if (n.length !== 0)
    for (const e of n) {
      if (e instanceof HTMLStyleElement) {
        ae(e.textContent ?? "");
        continue;
      }
      e instanceof HTMLLinkElement && (e.sheet || await new Promise((t) => {
        e.addEventListener("load", () => t(), { once: !0 });
      }), ae(Array.from(e.sheet?.cssRules ?? []).map((t) => t.cssText).join(`
`)));
    }
}, ie = (n) => {
  const e = n.adoptedStyleSheets ?? [], t = Z.filter((r) => !e.includes(r));
  t.length > 0 && (n.adoptedStyleSheets = [...e, ...t]);
}, ae = (n) => {
  const e = n.trim();
  if (e.length > 0) {
    const t = new CSSStyleSheet();
    t.replaceSync(e), Z.push(t);
  }
}, je = () => Z.length > 0, Be = class extends HTMLElement {
  constructor(n, e) {
    super(), this._unsubscribers = [], this._renderScheduled = !1, this._booleanProperties = /* @__PURE__ */ new Set(), this._meta = n, this._component = e, this._component.elementRef = this, this._root = this.attachShadow({ mode: "open" }), qe(this._root), this._style = this.renderStyles(), this.observe(), this._component.onInit && this._component.onInit();
  }
  get component() {
    return this._component;
  }
  async connectedCallback() {
    this.render(), this._component.onCreate !== void 0 && this._component.onCreate();
  }
  disconnectedCallback() {
    this._unsubscribers.forEach((e) => e()), this._unsubscribers = [];
    const n = this._root.__parts;
    if (n) {
      for (const e of n) if (e.actionCleanup) try {
        e.actionCleanup();
      } catch (t) {
        console.error("Action directive cleanup failed:", t);
      } finally {
        e.actionCleanup = void 0;
      }
    }
    this._component.onDestroy !== void 0 && this._component.onDestroy();
  }
  attributeChangedCallback(n, e, t) {
    const r = n.replace(/-([a-z])/g, (s, o) => o.toUpperCase());
    if (this._component[r] !== void 0) {
      let s = t;
      this._booleanProperties.has(r) && (s = t !== null && t !== "false"), this._component[r] = s;
    }
    this.scheduleRender(), this._component.onAttributeChange !== void 0 && this._component.onAttributeChange(n, e, t);
  }
  renderStyles() {
    const n = document.createElement("style");
    return this._meta.styles && se(this._meta.styles(), n), this._root.appendChild(n);
  }
  render() {
    this._meta.template && (se(this._meta.template(this._component, this.getAttributeValues()), this._root), this._style.parentNode !== this._root && this._root.appendChild(this._style)), this._component.onRender !== void 0 && this._component.onRender();
  }
  scheduleRender() {
    this._renderScheduled || (this._renderScheduled = !0, queueMicrotask(() => {
      this._renderScheduled = !1, this.isConnected && this.render();
    }));
  }
  observe() {
    const n = [], e = /* @__PURE__ */ new Set();
    let t = this._component;
    for (; t && t !== Object.prototype; ) {
      for (const s of Object.getOwnPropertyNames(t)) e.has(s) || (e.add(s), n.push(s));
      t = Object.getPrototypeOf(t);
    }
    const r = n.filter((s) => {
      const o = this._component[s];
      return s.startsWith("_") ? !1 : Oe(o) ? (this.subscribeToSignal(o), !1) : typeof o == "function" ? !1 : s !== "elementRef" && s !== "constructor";
    });
    for (const s of r) {
      const o = this.getPropertyDescriptor(this._component, s), i = Object.getOwnPropertyDescriptor(this, s)?.value;
      let a = i === void 0 ? this._component[s] : i;
      typeof a == "boolean" && this._booleanProperties.add(s);
      let c = () => a, h = (u) => {
        a !== u && (this._component.onPropertyChange?.(s, a, u), a = u, this.scheduleRender());
      };
      if (o?.get) {
        const u = o.get;
        c = () => u.call(this._component) ?? a;
      }
      if (o?.set) {
        const u = o.set, d = h;
        h = (l) => {
          u.call(this._component, l), d(l);
        };
      }
      Object.defineProperty(this._component, s, {
        get: c,
        set: h,
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(this, s, {
        get: c,
        set: h,
        enumerable: !0,
        configurable: !0
      });
    }
  }
  getPropertyDescriptor(n, e) {
    let t = n;
    for (; t && t !== Object.prototype; ) {
      const r = Object.getOwnPropertyDescriptor(t, e);
      if (r) return r;
      t = Object.getPrototypeOf(t);
    }
  }
  getAttributeValues() {
    const n = {};
    return this.getAttributeNames().forEach((e) => {
      n[e] = this.getAttribute(e) ?? "";
    }), n;
  }
  subscribeToSignal(n) {
    const e = n.subscribe(() => this.scheduleRender());
    this._unsubscribers.push(e);
  }
};
function be(n) {
  return function(e) {
    if (customElements.get(n.selector) === void 0) {
      const t = class extends Be {
        constructor() {
          const s = [], o = e.params;
          if (o && Array.isArray(o)) for (const i of o) {
            const a = o[i];
            a && typeof a == "object" && a.__injectionToken ? s.push(P.get(a.__injectionToken)) : s.push(void 0);
          }
          super(n, Reflect.construct(e, s));
        }
        static #e = this.observedAttributes = n.attributes ?? [];
      }, r = e;
      r.selector = n.selector, customElements.define(n.selector, t);
    }
  };
}
var Y = class Ce extends Error {
  constructor(e, t, r) {
    super(e), this.config = t, this.code = r, this.name = "HttpBaseError", Object.setPrototypeOf(this, Ce.prototype);
  }
}, Fe = class Re extends Y {
  constructor(e, t, r) {
    super(e, r, `HTTP_${t.status}`), this.response = t, this.name = "HttpError", Object.setPrototypeOf(this, Re.prototype);
  }
}, Ke = class xe extends Y {
  constructor(e, t) {
    super(e, t, "NETWORK_ERROR"), this.name = "NetworkError", Object.setPrototypeOf(this, xe.prototype);
  }
}, He = class Ee extends Y {
  constructor(e, t) {
    super(e, t, "ABORTED"), this.name = "AbortError", Object.setPrototypeOf(this, Ee.prototype);
  }
}, Ve = class {
  constructor() {
    this._pendingRequests = /* @__PURE__ */ new Map();
  }
  generateRequestKey(n, e, t) {
    let r = `${n}:${e}`;
    return t && (r += `:${this.hashBody(t)}`), r;
  }
  hasPendingRequest(n) {
    return this._pendingRequests.has(n);
  }
  getPendingRequest(n) {
    const e = this._pendingRequests.get(n);
    return e ? e.promise : null;
  }
  addPendingRequest(n, e) {
    const t = this.generateRequestKey(n.method || "GET", n.url || "", n.body);
    this._pendingRequests.set(t, {
      promise: e,
      abortController: n.abortController
    }), e.finally(() => {
      this.removePendingRequest(t);
    });
  }
  cancelPendingRequest(n, e) {
    const t = this._pendingRequests.get(n);
    t && (t.abortController.abort(e), this._pendingRequests.delete(n));
  }
  cancelAllRequests(n) {
    this._pendingRequests.forEach((e) => {
      e.abortController.abort(n);
    }), this._pendingRequests.clear();
  }
  removePendingRequest(n) {
    this._pendingRequests.get(n) && this._pendingRequests.delete(n);
  }
  hashBody(n) {
    let e;
    return typeof n == "string" ? e = n : n instanceof FormData ? e = "[FormData]" : n instanceof Blob ? e = `[Blob:${n.size}]` : n instanceof ArrayBuffer ? e = `[ArrayBuffer:${n.byteLength}]` : n instanceof URLSearchParams ? e = n.toString() : typeof n == "object" && n !== null ? e = JSON.stringify(n) : e = String(n), this.hashCode(e).toString();
  }
  hashCode(n) {
    let e = 0;
    for (let t = 0; t < n.length; t++) {
      const r = n.charCodeAt(t);
      e = (e << 5) - e + r, e = e & e;
    }
    return e;
  }
}, ce = class {
  constructor(n) {
    this._requestManager = new Ve(), this._interceptors = {
      request: [],
      response: []
    }, this.interceptors = {
      request: (e) => {
        this._interceptors.request.push(e);
      },
      response: (e) => {
        this._interceptors.response.push(e);
      }
    }, this._clientConfig = {
      defaultHeaders: {},
      ...n
    };
  }
  async get(n, e) {
    return this.internalRequest({
      method: "GET",
      ...e,
      url: n,
      deduplicate: e?.deduplicate ?? !0
    });
  }
  async post(n, e, t) {
    return this.internalRequest({
      method: "POST",
      ...t,
      url: n,
      body: e
    });
  }
  async put(n, e, t) {
    return this.internalRequest({
      method: "PUT",
      ...t,
      url: n,
      body: e
    });
  }
  async patch(n, e, t) {
    return this.internalRequest({
      method: "PATCH",
      ...t,
      url: n,
      body: e
    });
  }
  async delete(n, e) {
    return this.internalRequest({
      method: "DELETE",
      ...e,
      url: n
    });
  }
  async internalRequest(n) {
    let e = this.mergeConfig(n);
    if (e = await this.executeRequestInterceptors(e), e.cancel?.cancelled) {
      e.cancel.cancelReason && console.log("[HttpClient] Request cancelled:", e.cancel.cancelReason);
      let r = {
        data: null,
        status: 0,
        statusText: "Request Cancelled",
        headers: new Headers(),
        config: e
      };
      return e.cancel.cancelledResponse && (r = {
        ...r,
        ...e.cancel.cancelledResponse
      }), Promise.resolve(r);
    }
    e.abortController === void 0 && (e.abortController = new AbortController());
    let t = await this.executeRequest(e);
    return t = await this.executeResponseInterceptors(t), t;
  }
  async executeRequest(n) {
    if (n.deduplicate === !0) {
      const t = this._requestManager.generateRequestKey(n.method, n.url, n.body);
      if (this._requestManager.hasPendingRequest(t)) return this._requestManager.getPendingRequest(t);
    }
    const e = fetch(n.url, {
      method: n.method,
      headers: n.headers,
      body: this.prepareBody(n.body),
      credentials: n.credentials,
      mode: n.mode,
      signal: n.abortController?.signal
    }).then(async (t) => {
      const r = {
        data: await this.parseResponse(t, n.onProgress),
        status: t.status,
        statusText: t.statusText,
        headers: t.headers,
        config: n
      };
      if (!t.ok) throw new Fe(`HTTP Error: ${t.status} ${t.statusText}`, r, n);
      return r;
    }).catch((t) => {
      throw t instanceof Error && t.name === "AbortError" ? new He("Request aborted", n) : new Ke((t instanceof Error ? t.message : "Network error") || "Network error", n);
    });
    return n.deduplicate === !0 && this._requestManager.addPendingRequest(n, e), await e;
  }
  async executeRequestInterceptors(n) {
    for (const e of this._interceptors.request) try {
      if (n = await e.intercept(n), n.cancel?.cancelled) break;
    } catch (t) {
      throw e.error && await e.error(t), t;
    }
    return n;
  }
  async executeResponseInterceptors(n) {
    for (const e of this._interceptors.response) try {
      n = await e.intercept(n);
    } catch (t) {
      throw e.error && await e.error(t), t;
    }
    return n;
  }
  mergeConfig(n) {
    return {
      ...this._clientConfig,
      ...n,
      headers: {
        ...this._clientConfig.defaultHeaders,
        ...n.headers
      },
      url: this.buildUrl(n.url ?? "", n.params)
    };
  }
  buildUrl(n, e) {
    let t = `${this._clientConfig.baseURL || ""}${n}`;
    if (e) {
      const r = Object.entries(e).map(([s, o]) => `${encodeURIComponent(s)}=${encodeURIComponent(String(o))}`).join("&");
      t += `${t.includes("?") ? "&" : "?"}${r}`;
    }
    return t;
  }
  prepareBody(n) {
    return n == null ? null : n instanceof FormData || n instanceof Blob || n instanceof ArrayBuffer || n instanceof URLSearchParams || n instanceof ReadableStream || typeof n == "string" ? n : JSON.stringify(n);
  }
  async parseResponse(n, e) {
    const t = n.headers.get("content-type") || "", r = parseInt(n.headers.get("content-length") || "0", 10);
    if (e && n.body && r > 0) {
      const s = n.body.getReader();
      let o = 0;
      const i = [];
      for (; ; ) {
        const { done: c, value: h } = await s.read();
        if (c) break;
        i.push(h), o += h.length, e({
          loaded: o,
          total: r,
          percentage: o / r * 100
        });
      }
      const a = new Blob(i);
      if (t.includes("application/json")) {
        const c = await a.text();
        return JSON.parse(c);
      }
      return a;
    }
    return t.includes("application/json") ? await n.json() : t.includes("text/") ? await n.text() : t.includes("application/octet-stream") || t.includes("image/") ? await n.blob() : await n.text();
  }
};
function gt(n, e) {
  return (t) => {
    const r = new ce(n);
    t.bindValue(ce, r), e?.request && e.request.forEach((s) => {
      r.interceptors.request(s);
    }), e?.response && e.response.forEach((s) => {
      r.interceptors.response(s);
    });
  };
}
function _t(n) {
  return { canActivate: n };
}
function yt(n) {
  return { canDeactivate: n };
}
function vt(n) {
  return { resolve: n };
}
var H = class {
  constructor(n, e) {
    this._reEscape = /[-[\]{}()+?.,\\^$|#\s]/g, this._reParam = /([:*])(\w+)/g, this._names = [], this._isWildcard = !1, this._route = n, this._rules = e, this._isWildcard = n.includes("*");
    let t = this._route.replace(this._reEscape, "\\$&");
    t = t.replace(this._reParam, (r, s, o) => (this._names.push(o), s === ":" ? "([^/]*)" : "(.*)")), this._routeRegex = /* @__PURE__ */ new RegExp("^" + t + "$"), this._prefixRegex = /* @__PURE__ */ new RegExp("^" + t + "(?:/|$)");
  }
  parse(n) {
    let e = 0, t, r;
    const s = {}, o = n.match(this._routeRegex);
    if (!o) return null;
    for (; e < this._names.length; ) {
      if (t = this._names[e++], r = o[e], this._rules && t in this._rules && !this.validateRule(this._rules[t], r)) return null;
      s[t] = r;
    }
    return s;
  }
  parsePrefix(n) {
    if (this._route === "") return {
      params: {},
      matchedPath: "",
      remainingPath: n
    };
    const e = n.match(this._prefixRegex);
    if (!e) return null;
    const t = {};
    for (let s = 0; s < this._names.length; s++) {
      const o = this._names[s], i = e[s + 1];
      if (this._rules && o in this._rules && !this.validateRule(this._rules[o], i)) return null;
      t[o] = i;
    }
    const r = this.calculateMatchedPath(n);
    return {
      params: t,
      matchedPath: r,
      remainingPath: n.slice(r.length).replace(/^\//, "")
    };
  }
  stringify(n) {
    let e, t = this._route;
    for (const r in n)
      e = /* @__PURE__ */ new RegExp("[:*]" + r + "\\b"), t = t.replace(e, n[r]);
    return t.replace(this._reParam, "");
  }
  calculateMatchedPath(n) {
    if (this._isWildcard) return n;
    const e = this._route.split("/").filter(Boolean);
    return n.split("/").filter(Boolean).slice(0, e.length).join("/");
  }
  validateRule(n, e) {
    const t = Object.prototype.toString.call(n).charAt(8);
    return t === "R" ? n.test(e) : t === "F" ? n(e) : n === e;
  }
};
const We = "melodic:route-context";
var wt = class extends CustomEvent {
  constructor(n) {
    super(We, {
      bubbles: !1,
      composed: !0,
      detail: n
    });
  }
};
function Pe(n, e, t, r, s) {
  for (const o of n) {
    const i = new H(o.path);
    if (o.redirectTo && o.path === e) return {
      matches: r,
      params: s,
      isExactMatch: !1,
      redirectTo: o.redirectTo
    };
    const a = i.parse(e);
    if (a !== null) {
      const c = t ? `${t}/${o.path}` : o.path, h = {
        route: o,
        params: a,
        matchedPath: o.path,
        remainingPath: "",
        fullPath: c,
        children: o.children
      };
      return Object.assign(s, a), r.push(h), {
        matches: r,
        params: s,
        isExactMatch: !0
      };
    }
    if (o.children || o.loadChildren) {
      const c = i.parsePrefix(e);
      if (c && c.params !== null) {
        const h = t ? `${t}/${c.matchedPath}` : c.matchedPath, u = {
          route: o,
          params: c.params,
          matchedPath: c.matchedPath,
          remainingPath: c.remainingPath,
          fullPath: h,
          children: o.children
        };
        return Object.assign(s, c.params), r.push(u), o.children && c.remainingPath ? Pe(o.children, c.remainingPath, h, r, s) : {
          matches: r,
          params: s,
          isExactMatch: c.remainingPath === ""
        };
      }
    }
  }
  return {
    matches: r,
    params: s,
    isExactMatch: !1
  };
}
function V(n, e, t = "") {
  const r = Pe(n, e.startsWith("/") ? e.slice(1) : e, t, [], {});
  return {
    matches: r.matches,
    params: r.params,
    isExactMatch: r.isExactMatch,
    redirectTo: r.redirectTo
  };
}
function Ge(n, e) {
  for (const t of n) {
    if (t.name === e) return t;
    if (t.children) {
      const r = Ge(t.children, e);
      if (r) return r;
    }
  }
  return null;
}
function Ue(n, e, t = {}) {
  const r = [];
  function s(o, i) {
    for (const a of o) {
      if (a.name === i) {
        const c = new H(a.path);
        return r.push(c.stringify(t)), !0;
      }
      if (a.children) {
        const c = new H(a.path).stringify(t);
        if (s(a.children, i))
          return r.unshift(c), !0;
      }
    }
    return !1;
  }
  return s(n, e) ? "/" + r.filter(Boolean).join("/") : null;
}
function x(n, e, t, r) {
  var s = arguments.length, o = s < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, i;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(n, e, t, r);
  else for (var a = n.length - 1; a >= 0; a--) (i = n[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(e, t, o) : i(e, t)) || o);
  return s > 3 && o && Object.defineProperty(e, t, o), o;
}
var W = class {
  constructor() {
    this._matchStack = [], this._contexts = /* @__PURE__ */ new Map(), this._currentMatchResult = null, this._resolvedData = /* @__PURE__ */ new Map();
  }
  setMatchResult(e) {
    this._currentMatchResult = e, this._matchStack = e.matches, this._contexts.clear();
    let t = "";
    const r = [], s = {};
    for (let o = 0; o < e.matches.length; o++) {
      const i = e.matches[o];
      r.push(i), Object.assign(s, i.params);
      const a = {
        depth: o,
        routes: i.children ?? [],
        currentMatch: i,
        ancestorMatches: [...r],
        params: { ...s },
        remainingPath: i.remainingPath,
        basePath: t,
        parent: o > 0 ? this._contexts.get(o - 1) : void 0
      };
      this._contexts.set(o, a), t = i.fullPath;
    }
  }
  setResolvedData(e, t) {
    this._resolvedData.set(e, t);
  }
  clearResolvedData() {
    this._resolvedData.clear();
  }
  getContextForDepth(e) {
    return this._contexts.get(e);
  }
  getChildRoutesForDepth(e) {
    const t = this._contexts.get(e - 1);
    return e === 0 ? [] : t?.currentMatch?.children ?? [];
  }
  getRemainingPathForDepth(e) {
    return e === 0 ? window.location.pathname : this._contexts.get(e - 1)?.remainingPath ?? "";
  }
  getParamsForDepth(e) {
    return this._contexts.get(e)?.params ?? {};
  }
  getCurrentParams() {
    return this._currentMatchResult?.params ?? {};
  }
  getMatchStack() {
    return [...this._matchStack];
  }
  getCurrentMatchResult() {
    return this._currentMatchResult;
  }
  getMergedRouteData(e) {
    const t = e ?? this._matchStack.length - 1, r = {};
    for (let s = 0; s <= t && s < this._matchStack.length; s++) {
      const o = this._matchStack[s];
      o.route.data && Object.assign(r, o.route.data);
    }
    return r;
  }
  getMergedResolvedData(e) {
    const t = e ?? this._matchStack.length - 1, r = {};
    for (let s = 0; s <= t; s++) {
      const o = this._resolvedData.get(s);
      o && Object.assign(r, o);
    }
    return r;
  }
  getResolvedDataForDepth(e) {
    return this._resolvedData.get(e);
  }
};
W = x([Q()], W);
function k(n, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(n, e);
}
var ee = (n, e, t, r) => new PopStateEvent("History", { state: {
  type: n,
  data: e,
  url: r,
  host: window.location.host,
  hostName: window.location.hostname,
  href: window.location.href,
  pathName: window.location.pathname,
  port: window.location.port,
  protocol: window.location.protocol,
  params: new URLSearchParams(window.location.search),
  title: t
} }), ze = history.pushState;
history.pushState = (n, e, t) => {
  ze.apply(history, [
    n,
    e,
    t
  ]);
  const r = new CustomEvent("NavigationEvent", { detail: ee("push", n, e, t) });
  window.dispatchEvent(r);
};
var Xe = history.replaceState;
history.replaceState = (n, e, t) => {
  Xe.apply(history, [
    n,
    e,
    t
  ]);
  const r = new CustomEvent("NavigationEvent", { detail: ee("replace", n, e, t) });
  window.dispatchEvent(r);
};
var S = class {
  constructor() {
    this._routes = [], this._currentMatches = [], this._resolversExecutedForPath = null, this._currentPath = `${window.location.pathname}${window.location.search}`, this._contextService = new W(), window.addEventListener("NavigationEvent", (e) => {
      this._route = e.detail.state;
    }), window.addEventListener("popstate", (e) => {
      this.handlePopState(e);
    });
  }
  setRoutes(e) {
    this._routes = e;
  }
  getRoutes() {
    return this._routes;
  }
  getContextService() {
    return this._contextService;
  }
  getRoute() {
    return this._route;
  }
  getParams() {
    return this._contextService.getCurrentParams();
  }
  getParam(e) {
    return this._contextService.getCurrentParams()[e];
  }
  getQueryParams() {
    return new URLSearchParams(window.location.search);
  }
  getCurrentMatches() {
    return [...this._currentMatches];
  }
  getRouteData(e) {
    return this._contextService.getMergedRouteData(e);
  }
  getResolvedData(e) {
    return this._contextService.getMergedResolvedData(e);
  }
  matchPath(e) {
    return V(this._routes, e);
  }
  setCurrentMatches(e) {
    this._currentMatches = e.matches, this._contextService.setMatchResult(e);
  }
  async runResolvers(e) {
    const t = `${window.location.pathname}${window.location.search}`;
    if (this._resolversExecutedForPath === t)
      return this._resolversExecutedForPath = null, { success: !0 };
    const r = await this.runResolversInternal(e);
    return this._resolversExecutedForPath = null, r;
  }
  async navigate(e, t = {}) {
    const { data: r, replace: s = !1, queryParams: o, skipGuards: i = !1, skipResolvers: a = !1, scrollToTop: c = !0 } = t;
    let h = e;
    if (o && Object.keys(o).length > 0 && (h = `${e}?${new URLSearchParams(o).toString()}`), !i && this._currentMatches.length > 0) {
      const d = await this.runDeactivationGuards(h);
      if (d !== !0)
        return typeof d == "string" ? this.navigate(d, {
          ...t,
          skipGuards: !0
        }) : {
          success: !1,
          error: "Navigation blocked by guard"
        };
    }
    const u = this.matchPath(e);
    if (u.redirectTo) return this.navigate(u.redirectTo, {
      ...t,
      replace: !0
    });
    if (!i && u.matches.length > 0) {
      const d = await this.runGuards(u);
      if (d !== !0)
        return typeof d == "string" ? this.navigate(d, {
          ...t,
          skipGuards: !0
        }) : {
          success: !1,
          error: "Navigation blocked by guard"
        };
    }
    if (!a && u.matches.length > 0) {
      const d = await this.runResolversInternal(u);
      if (!d.success) return {
        success: !1,
        error: d.error ?? "Navigation blocked by resolver"
      };
      this._resolversExecutedForPath = h;
    }
    if (s ? history.replaceState(r, "", h) : history.pushState(r, "", h), this._currentPath = h, c) {
      const d = h.includes("#") ? h.split("#")[1] : null;
      if (d) {
        const l = document.getElementById(d);
        l && l.scrollIntoView();
      } else window.scrollTo(0, 0);
    }
    return {
      success: !0,
      url: h
    };
  }
  async navigateByName(e, t = {}, r = {}) {
    const s = Ue(this._routes, e, t);
    return s ? this.navigate(s, r) : {
      success: !1,
      error: `Route with name '${e}' not found`
    };
  }
  replace(e, t) {
    history.replaceState(t, "", e), this._currentPath = `${window.location.pathname}${window.location.search}`;
  }
  back() {
    history.back();
  }
  forward() {
    history.forward();
  }
  go(e) {
    history.go(e);
  }
  async runDeactivationGuards(e) {
    for (const t of this._currentMatches) {
      const r = t.route.canDeactivate ?? [];
      for (const s of r) {
        const o = this.createGuardContext(t, {
          matches: this._currentMatches,
          params: this._contextService.getCurrentParams(),
          isExactMatch: !0
        });
        o.targetPath = e;
        const i = await this.executeGuard(s, "canDeactivate", o);
        if (i !== !0) return i;
      }
    }
    return !0;
  }
  async runGuards(e) {
    for (const t of e.matches) {
      const r = t.route.canActivate ?? [];
      for (const s of r) {
        const o = this.createGuardContext(t, e), i = await this.executeGuard(s, "canActivate", o);
        if (i !== !0) return i;
      }
    }
    return !0;
  }
  async executeGuard(e, t, r) {
    const s = e[t];
    if (!s) return !0;
    try {
      const o = s.call(e, r);
      return o instanceof Promise ? await o : o;
    } catch (o) {
      return console.error("Guard error:", o), !1;
    }
  }
  createGuardContext(e, t) {
    return {
      route: e,
      matchedRoutes: t.matches,
      params: t.params,
      queryParams: new URLSearchParams(window.location.search),
      targetPath: window.location.pathname,
      currentPath: window.location.pathname,
      data: e.route.data
    };
  }
  async runResolversInternal(e) {
    this._contextService.clearResolvedData();
    for (let t = 0; t < e.matches.length; t++) {
      const r = e.matches[t], s = r.route.resolve;
      if (!s) continue;
      const o = {}, i = this.createResolverContext(r, e);
      for (const [a, c] of Object.entries(s)) try {
        o[a] = await this.executeResolver(c, i);
      } catch (h) {
        return console.error(`Resolver '${a}' failed:`, h), {
          success: !1,
          error: `Resolver '${a}' failed: ${h instanceof Error ? h.message : String(h)}`
        };
      }
      this._contextService.setResolvedData(t, o);
    }
    return { success: !0 };
  }
  async handlePopState(e) {
    const t = `${window.location.pathname}${window.location.search}`, r = await this.runDeactivationGuards(t);
    if (r !== !0) {
      typeof r == "string" ? await this.navigate(r, {
        replace: !0,
        skipGuards: !0
      }) : history.replaceState(e.state, "", this._currentPath);
      return;
    }
    this._currentPath = t;
    const s = new CustomEvent("NavigationEvent", { detail: ee("push", e.state, "", window.location.pathname) });
    window.dispatchEvent(s);
  }
  async executeResolver(e, t) {
    const r = e.resolve(t);
    return r instanceof Promise ? await r : r;
  }
  createResolverContext(e, t) {
    return {
      route: e,
      matchedRoutes: t.matches,
      params: t.params,
      queryParams: new URLSearchParams(window.location.search),
      targetPath: window.location.pathname
    };
  }
};
S = x([Q(), k("design:paramtypes", [])], S);
var N = /* @__PURE__ */ new Map(), Se = (n) => {
  if (N.has(n)) return N.get(n);
  const e = n.toLowerCase();
  for (const [t, r] of N) if (t.toLowerCase() === e) return r;
};
function Me(n, e) {
  N.set(n, e);
}
function Je(n) {
  return Se(n);
}
function Rt(n) {
  return Se(n) !== void 0;
}
function xt(n) {
  return N.delete(n);
}
function Et() {
  return Array.from(N.keys());
}
function D(n) {
  return typeof n == "object" && n !== null && "__directive" in n;
}
var B = `m${Math.random().toString(36).slice(2, 9)}`, Qe = `<!--${B}-->`, te = `__${B}_`, le = new RegExp(`${te}(\\d+)__`, "g"), q = (n) => `${te}${n}__`, $ = /* @__PURE__ */ new Map(), he = /* @__PURE__ */ new WeakMap();
function ue(n) {
  let e = he.get(n);
  return e === void 0 && (e = n.join(B), he.set(n, e)), e;
}
var Ze = class O {
  constructor(e, t) {
    this.strings = e, this.values = t;
  }
  /**
  * Optimized render for single-use containers (like repeat items).
  * Returns the rendered nodes directly.
  */
  renderOnce(e) {
    const t = ue(this.strings), r = this.getTemplate(t), s = r.element.content.cloneNode(!0), o = this.prepareParts(s, r);
    return this.commit(o), e.appendChild(s), e.__parts = o, e.__templateKey = t, Array.from(e.childNodes);
  }
  renderInto(e) {
    const t = ue(this.strings), { element: r } = this.getTemplate(t), s = e.__templateKey;
    if (s && s !== t) {
      const i = e.__parts;
      i && this.cleanupParts(i), delete e.__parts;
    }
    if (!e.__parts) {
      const i = r.content.cloneNode(!0), a = this.prepareParts(i, this.getTemplate(t));
      e.__parts = a, e.__templateKey = t, this.commit(a), e.textContent = "", e.appendChild(i);
      return;
    }
    e.__templateKey || (e.__templateKey = t);
    const o = e.__parts;
    this.commit(o);
  }
  getTemplate(e) {
    let t = $.get(e);
    if (t) return t;
    const r = [];
    let s = this.strings[0];
    const o = this.getAttributePreProcessor(r);
    let i = null, a = null;
    for (let p = 1; p < this.strings.length; p++) {
      const m = this.strings[p], b = p - 1, g = /([@.:]?[\w:-]+)\s*=\s*["']?$/.exec(s), w = /([@.:]?[\w:-]+)\s*=\s*(["'])([^"']*)$/.exec(s);
      let v = "___";
      if (i) s += q(b);
      else {
        const R = w?.[1]?.charAt(0), C = R !== void 0 && Object.keys(o).includes(R);
        if (w && !C)
          s += q(b), i = w[1], a = w[2];
        else {
          if (g) {
            v = "__";
            const A = g[1].charAt(0);
            Object.keys(o).includes(A) && (v = A);
          }
          if (v === "__" && g) {
            s += q(b), i = g[1];
            const A = /(["'])$/.exec(g[0]);
            a = A ? A[1] : null;
          } else s = o[v](b, s, g ? g[1] : void 0, g);
        }
      }
      s += m, i && (a ? m.includes(a) && (i = null, a = null) : /[\s>]/.test(m) && (i = null, a = null));
    }
    const c = document.createElement("template");
    c.innerHTML = s;
    const h = [];
    let u = 0;
    const d = [], l = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map();
    for (const p of r) switch (p.type) {
      case "event":
        l.set(p.index, p);
        break;
      case "property":
        f.set(p.index, p);
        break;
      case "action":
        y.set(p.index, p);
        break;
      case "node":
        d.push(p);
        break;
      default:
        break;
    }
    const _ = (p, m) => {
      if (p.nodeType === Node.COMMENT_NODE) {
        if (p.data === B) {
          const g = d[u++];
          g && h.push({
            path: [...m],
            type: "node",
            index: g.index
          });
        }
      } else if (p.nodeType === Node.ELEMENT_NODE) {
        const g = p;
        for (let w = g.attributes.length - 1; w >= 0; w--) {
          const v = g.attributes[w];
          if (v.name.startsWith("__event-")) {
            const R = parseInt(v.name.match(/__event-(\d+)__/)?.[1] || "0"), C = l.get(R);
            C && h.push({
              path: [...m],
              type: "event",
              index: C.index,
              name: C.name
            });
          } else if (v.name.startsWith("__prop-")) {
            const R = parseInt(v.name.match(/__prop-(\d+)__/)?.[1] || "0"), C = f.get(R);
            C && h.push({
              path: [...m],
              type: "property",
              index: C.index,
              name: C.name
            });
          } else if (v.name.startsWith("__action-")) {
            const R = parseInt(v.name.match(/__action-(\d+)__/)?.[1] || "0"), C = y.get(R);
            C && h.push({
              path: [...m],
              type: "action",
              index: C.index,
              name: C.name
            });
          } else if (v.name.startsWith(":")) h.push({
            path: [...m],
            type: "action",
            index: -1,
            name: v.name.slice(1),
            staticValue: v.value
          });
          else if (v.value.includes(te)) {
            const R = this.parseAttributeValue(v.value);
            if (R) {
              const C = R.indices.length > 1 || R.strings.some((A) => A.length > 0);
              h.push({
                path: [...m],
                type: "attribute",
                index: R.indices[0],
                name: v.name,
                attributeStrings: C ? R.strings : void 0,
                attributeIndices: C ? R.indices : void 0
              });
            }
          }
        }
      }
      const b = p.childNodes;
      for (let g = 0; g < b.length; g++)
        m.push(g), _(b[g], m), m.pop();
    };
    if (_(c.content, []), t = {
      element: c,
      parts: r,
      partPaths: h
    }, $.size >= 500) {
      const p = $.keys().next().value;
      p && $.delete(p);
    }
    return $.set(e, t), t;
  }
  getAttributePreProcessor(e) {
    return {
      "@": (t, r, s, o) => (e.push({
        type: "event",
        index: t,
        name: s?.slice(1)
      }), r.slice(0, -(o?.[0].length ?? 0)) + `__event-${t}__=""`),
      ".": (t, r, s, o) => (e.push({
        type: "property",
        index: t,
        name: s?.slice(1)
      }), r.slice(0, -(o?.[0].length ?? 0)) + `__prop-${t}__=""`),
      ":": (t, r, s, o) => (e.push({
        type: "action",
        index: t,
        name: s?.slice(1)
      }), r.slice(0, -(o?.[0].length ?? 0)) + `__action-${t}__=""`),
      __: (t, r, s) => r + q(t),
      ___: (t, r) => (e.push({
        type: "node",
        index: t
      }), r + Qe)
    };
  }
  prepareParts(e, t) {
    const r = [], { partPaths: s } = t;
    for (const o of s) {
      let i = e;
      for (const a of o.path) i = i.childNodes[a];
      if (o.type === "node") {
        const a = document.createTextNode("");
        i.parentNode.replaceChild(a, i), r.push({
          type: "node",
          index: o.index,
          node: a
        });
      } else if (o.type === "event") {
        const a = i;
        a.removeAttribute(`__event-${o.index}__`), r.push({
          type: "event",
          index: o.index,
          name: o.name,
          node: a
        });
      } else if (o.type === "property") {
        const a = i;
        a.removeAttribute(`__prop-${o.index}__`), r.push({
          type: "property",
          index: o.index,
          name: o.name,
          node: a
        });
      } else if (o.type === "action") {
        const a = i;
        o.index >= 0 ? a.removeAttribute(`__action-${o.index}__`) : a.removeAttribute(`:${o.name}`), r.push({
          type: "action",
          index: o.index,
          name: o.name,
          node: a,
          staticValue: o.staticValue
        });
      } else if (o.type === "attribute") {
        const a = i;
        a.removeAttribute(o.name), r.push({
          type: "attribute",
          index: o.index,
          name: o.name,
          node: a,
          attributeStrings: o.attributeStrings,
          attributeIndices: o.attributeIndices
        });
      }
    }
    return r;
  }
  parseAttributeValue(e) {
    const t = [], r = [];
    let s = 0, o;
    for (le.lastIndex = 0; (o = le.exec(e)) !== null; )
      t.push(e.slice(s, o.index)), r.push(Number(o[1])), s = o.index + o[0].length;
    return r.length === 0 ? null : (t.push(e.slice(s)), {
      strings: t,
      indices: r
    });
  }
  /**
  * Sets up markers for a node part to enable complex content rendering
  */
  ensureMarkers(e) {
    if (e.startMarker) return;
    const t = e.node.parentNode;
    if (!t) return;
    const r = document.createComment("part-start"), s = document.createComment("part-end");
    t.insertBefore(r, e.node), t.insertBefore(s, e.node.nextSibling), e.startMarker = r, e.endMarker = s;
  }
  /**
  * Clears previously rendered nodes between markers
  */
  clearRenderedNodes(e) {
    if (!(!e.renderedNodes || e.renderedNodes.length === 0)) {
      for (const t of e.renderedNodes) t.parentNode?.removeChild(t);
      e.renderedNodes = [], e.arrayState = void 0;
    }
  }
  cleanupParts(e) {
    for (const t of e) {
      if (t.actionCleanup) try {
        t.actionCleanup();
      } catch (r) {
        console.error("Action directive cleanup failed:", r);
      } finally {
        t.actionCleanup = void 0;
      }
      t.renderedNodes && t.renderedNodes.length > 0 && this.clearRenderedNodes(t);
    }
  }
  /**
  * Renders a nested TemplateResult into a node part
  */
  renderNestedTemplate(e, t) {
    this.ensureMarkers(e), this.clearRenderedNodes(e), e.node.textContent = "";
    const r = document.createDocumentFragment();
    t.renderInto(r), e.renderedNodes = Array.from(r.childNodes), e.endMarker.parentNode.insertBefore(r, e.endMarker);
  }
  /**
  * Renders a DOM Node into a node part
  */
  renderNode(e, t) {
    this.ensureMarkers(e), this.clearRenderedNodes(e), e.node.textContent = "", e.renderedNodes = [t], e.endMarker.parentNode.insertBefore(t, e.endMarker);
  }
  /**
  * Renders an array of values into a node part
  */
  renderArray(e, t) {
    this.ensureMarkers(e), e.node.textContent = "";
    const r = e.endMarker.parentNode, s = this.getKeyedValues(t);
    if (s) {
      const i = e.arrayState ?? {
        items: /* @__PURE__ */ new Map(),
        keys: []
      }, a = /* @__PURE__ */ new Map(), c = [];
      for (const u of s) {
        const d = i.items.get(u.key);
        if (d)
          this.updateArrayItem(d, u.value, r, e.endMarker), a.set(u.key, d);
        else {
          const l = this.createArrayItem(u.value, r, e.endMarker);
          a.set(u.key, {
            key: u.key,
            value: u.value,
            container: l.container,
            nodes: l.nodes
          });
        }
        c.push(u.key);
      }
      for (const [u, d] of i.items.entries()) if (!a.has(u)) for (const l of d.nodes) l.parentNode?.removeChild(l);
      let h = e.startMarker.nextSibling;
      for (const u of c) {
        const d = a.get(u);
        for (const l of d.nodes) {
          if (l === h) {
            h = h?.nextSibling ?? null;
            continue;
          }
          r.insertBefore(l, h ?? e.endMarker);
        }
      }
      e.arrayState = {
        items: a,
        keys: c
      }, e.renderedNodes = c.flatMap((u) => a.get(u).nodes);
      return;
    }
    this.clearRenderedNodes(e);
    const o = [];
    for (const i of t) if (i instanceof O) {
      const a = document.createDocumentFragment();
      i.renderInto(a);
      const c = Array.from(a.childNodes);
      o.push(...c), r.insertBefore(a, e.endMarker);
    } else if (i instanceof Node)
      o.push(i), r.insertBefore(i, e.endMarker);
    else if (i != null) {
      const a = document.createTextNode(String(i));
      o.push(a), r.insertBefore(a, e.endMarker);
    }
    e.renderedNodes = o;
  }
  getKeyedValues(e) {
    if (e.length === 0) return null;
    const t = [];
    for (const r of e) if (r && typeof r == "object" && r.__keyed === !0) {
      const s = r;
      t.push({
        key: s.key,
        value: s.value
      });
    } else return null;
    return t;
  }
  createArrayItem(e, t, r) {
    const s = document.createDocumentFragment();
    e instanceof O ? e.renderInto(s) : e instanceof Node ? s.appendChild(e) : e != null && s.appendChild(document.createTextNode(String(e)));
    const o = Array.from(s.childNodes);
    return t.insertBefore(s, r), {
      container: s,
      nodes: o
    };
  }
  updateArrayItem(e, t, r, s) {
    if (t instanceof O) {
      t.renderInto(e.container), e.value = t, e.nodes = Array.from(e.container.childNodes);
      return;
    }
    if (t !== e.value) {
      for (const o of e.nodes) o.parentNode?.removeChild(o);
      e.container = document.createDocumentFragment(), t instanceof Node ? e.container.appendChild(t) : t != null && e.container.appendChild(document.createTextNode(String(t))), e.nodes = Array.from(e.container.childNodes), r.insertBefore(e.container, s), e.value = t;
    }
  }
  commit(e) {
    for (const t of e) {
      const r = this.values[t.index], s = t.type === "attribute" && t.attributeIndices && t.attributeStrings;
      if (!(!s && !D(r) && t.type !== "action" && t.previousValue === r)) {
        switch (t.type) {
          case "node":
            t.node && (D(r) ? t.directiveState = r.render(t.node, t.directiveState) : r instanceof O ? this.renderNestedTemplate(t, r) : r instanceof Node ? this.renderNode(t, r) : Array.isArray(r) ? this.renderArray(t, r) : (this.clearRenderedNodes(t), t.node.textContent = String(r ?? "")));
            break;
          case "attribute":
            if (t.node && t.name) {
              const o = t.node;
              if (D(r)) t.directiveState = r.render(o, t.directiveState);
              else if (s) {
                const i = t.attributeStrings, a = t.attributeIndices;
                let c = i[0] ?? "";
                for (let h = 0; h < a.length; h++) {
                  const u = this.values[a[h]];
                  c += `${u ?? ""}${i[h + 1] ?? ""}`;
                }
                if (t.previousValue === c) break;
                c === "" && i.every((h) => h === "") ? o.removeAttribute(t.name) : o.setAttribute(t.name, c), t.previousValue = c;
                continue;
              } else r == null || r === !1 ? o.removeAttribute(t.name) : r === !0 ? o.setAttribute(t.name, "") : o.setAttribute(t.name, String(r));
            }
            break;
          case "property":
            t.node && t.name && (D(r) ? t.directiveState = r.render(t.node, t.directiveState) : t.node[t.name] = r);
            break;
          case "event":
            if (t.node && t.name) {
              const o = t.node;
              if (t.previousValue === r) break;
              t.previousValue && typeof t.previousValue == "function" && o.removeEventListener(t.name, t.previousValue), typeof r == "function" && o.addEventListener(t.name, r);
            }
            break;
          case "action":
            if (t.node && t.name) {
              const o = t.node, i = t.index >= 0 ? r : t.staticValue;
              if (t.index >= 0 && t.previousValue === i || t.index < 0 && t.actionCleanup !== void 0) continue;
              t.actionCleanup && (t.actionCleanup(), t.actionCleanup = void 0);
              const a = Je(t.name);
              if (a) {
                const c = a(o, i, t.name);
                typeof c == "function" ? t.actionCleanup = c : t.actionCleanup = () => {
                };
              } else console.warn(`Attribute directive ':${t.name}' not found in registry`);
            }
            break;
          default:
            break;
        }
        t.previousValue = r;
      }
    }
  }
};
function ne(n, ...e) {
  return new Ze(n, e);
}
const Ye = ne;
var de, fe = "melodic:outlet-register", G = class {
  constructor() {
    this._depth = 0, this._context = null, this._currentComponent = null, this._currentElement = null, this._childOutlets = /* @__PURE__ */ new Map(), this._parentOutlet = null, this._initialized = !1, this._navigationCleanup = null, this.routes = [], this.name = "primary";
  }
  onInit() {
    const e = () => this.onNavigate();
    window.addEventListener("NavigationEvent", e), this._navigationCleanup = () => window.removeEventListener("NavigationEvent", e), this.elementRef.addEventListener(fe, ((t) => {
      t.detail.outlet !== this && (t.stopPropagation(), this.registerChildOutlet(t.detail));
    }));
  }
  onCreate() {
    this.findParentOutlet(), queueMicrotask(() => {
      this._initialized = !0, this._depth === 0 && this.routes.length > 0 && this._router.setRoutes(this.routes), this._parentOutlet ? this.requestContextFromParent() : this.onNavigate();
    });
  }
  onDestroy() {
    this._navigationCleanup?.(), this._parentOutlet && this._parentOutlet.unregisterChildOutlet(this.name);
  }
  onPropertyChange(e) {
    e === "routes" && this._initialized && (this._depth === 0 && this._router.setRoutes(this.routes), this._currentComponent = null, this.onNavigate());
  }
  getDepth() {
    return this._depth;
  }
  getContext() {
    return this._context;
  }
  findParentOutlet() {
    let e = this.elementRef;
    for (; e; ) {
      const t = e.getRootNode();
      if (t instanceof ShadowRoot) {
        if (e = t.host, e.tagName.toLowerCase() !== "router-outlet") {
          const r = e.shadowRoot?.querySelector("router-outlet");
          if (r && r !== this.elementRef) {
            this._parentOutlet = r.component, this._depth = (this._parentOutlet?._depth ?? -1) + 1;
            return;
          }
        }
      } else {
        const r = e.closest?.("router-outlet");
        if (r && r !== this.elementRef) {
          this._parentOutlet = r.component, this._depth = (this._parentOutlet?._depth ?? -1) + 1;
          return;
        }
        break;
      }
    }
    this._depth = 0;
  }
  /**
  * Request context from parent outlet.
  */
  requestContextFromParent() {
    const e = new CustomEvent(fe, {
      bubbles: !0,
      composed: !0,
      detail: {
        outlet: this,
        callback: (t) => this.receiveContext(t)
      }
    });
    this.elementRef.dispatchEvent(e);
  }
  /**
  * Register a child outlet.
  */
  registerChildOutlet(e) {
    if (this._childOutlets.set(e.outlet.name, e.outlet), this._context?.currentMatch?.children) {
      const t = this.createChildContext();
      t && e.callback(t);
    }
  }
  unregisterChildOutlet(e) {
    this._childOutlets.delete(e);
  }
  receiveContext(e) {
    this._context = e, this.routes = e.routes, this.renderFromContext();
  }
  createChildContext() {
    if (!this._context?.currentMatch) return null;
    const e = this._context.currentMatch;
    return {
      depth: this._depth + 1,
      routes: e.children ?? [],
      currentMatch: void 0,
      ancestorMatches: [...this._context.ancestorMatches],
      params: { ...this._context.params },
      remainingPath: e.remainingPath,
      basePath: e.fullPath,
      parent: this._context
    };
  }
  onNavigate() {
    this._initialized && this._depth === 0 && this.matchAndRender(window.location.pathname);
  }
  /**
  * Match the current path and render (root outlet only).
  */
  async matchAndRender(e) {
    const t = this.routes.length > 0 ? this.routes : this._router.getRoutes();
    if (t.length === 0) return;
    const r = V(t, e);
    if (r.redirectTo) {
      window.location.pathname !== r.redirectTo && this._router.navigate(r.redirectTo, { replace: !0 });
      return;
    }
    if (r.matches.length > 0) {
      const s = await this._router.runResolvers(r);
      if (!s.success) {
        console.error("Resolver failed:", s.error), await this.render404();
        return;
      }
    }
    if (this._router.setCurrentMatches(r), r.matches.length > 0) {
      const s = r.matches[0];
      this._context = {
        depth: 0,
        routes: t,
        currentMatch: s,
        ancestorMatches: [s],
        params: s.params,
        remainingPath: s.remainingPath,
        basePath: "",
        parent: void 0
      }, await this.renderMatch(s, r);
    } else await this.render404();
  }
  async renderFromContext() {
    if (!this._context || this.routes.length === 0) return;
    const e = this._context.remainingPath, t = V(this.routes, e, this._context.basePath);
    if (t.redirectTo) {
      const r = this._context.basePath ? `/${this._context.basePath}/${t.redirectTo}`.replace(/\/+/g, "/") : t.redirectTo;
      window.location.pathname !== r && this._router.navigate(r, { replace: !0 });
      return;
    }
    if (t.matches.length > 0) {
      const r = t.matches[0];
      this._context = {
        ...this._context,
        currentMatch: r,
        ancestorMatches: [...this._context.ancestorMatches, r],
        params: {
          ...this._context.params,
          ...r.params
        }
      }, await this.renderMatch(r, t);
    } else await this.render404();
  }
  async renderMatch(e, t) {
    const r = e.route;
    if (r.component === this._currentComponent) {
      this.updateChildOutlets();
      return;
    }
    if (r.loadChildren && !e.children) try {
      const s = await r.loadChildren();
      e.children = s.routes, r.children = s.routes;
    } catch (s) {
      console.error("Failed to load child routes:", s), await this.render404();
      return;
    }
    if (r.loadComponent) try {
      await r.loadComponent();
    } catch (s) {
      console.error("Failed to load component:", s), await this.render404();
      return;
    }
    r.component && await this.renderComponent(r.component);
  }
  async renderComponent(e) {
    const t = this.elementRef.shadowRoot;
    if (!t) return;
    this._currentElement && (this._currentElement.remove(), this._currentElement = null), this._currentComponent = e;
    const r = document.createElement(e);
    r.__parentOutlet = this, t.appendChild(r), this._currentElement = r, queueMicrotask(() => this.updateChildOutlets());
  }
  updateChildOutlets() {
    const e = this.createChildContext();
    if (e)
      for (const [, t] of this._childOutlets) t.receiveContext(e);
  }
  async render404() {
    const e = this.routes.find((t) => t.path === "404" || t.path === "**");
    e?.component ? await this.renderComponent(e.component) : this._depth === 0 && this._router.navigate("/404", { replace: !0 });
  }
};
x([T(S), k("design:type", typeof (de = typeof S < "u" && S) == "function" ? de : Object)], G.prototype, "_router", void 0);
G = x([be({
  selector: "router-outlet",
  template: () => ne`<slot></slot>`
})], G);
var pe, U = class {
  constructor() {
    this._anchorElement = null, this._navigationCleanup = null, this.href = "", this.data = null, this.queryParams = {}, this.activeClass = "active", this.exactMatch = !1, this.replace = !1;
  }
  onCreate() {
    this._anchorElement = this.elementRef.shadowRoot?.querySelector("a") ?? null;
    const e = this.elementRef.getAttribute("href");
    e && (this.href = e);
    const t = this.elementRef.getAttribute("active-class");
    t && (this.activeClass = t), this.updateAnchorHref(), this.elementRef.addEventListener("click", (s) => {
      if (s.preventDefault(), s.ctrlKey || s.metaKey || s.shiftKey) {
        window.open(this.buildFullPath(), "_blank");
        return;
      }
      this.navigate();
    }, !1);
    const r = () => this.updateActiveState();
    window.addEventListener("NavigationEvent", r), this._navigationCleanup = () => window.removeEventListener("NavigationEvent", r), this.updateActiveState();
  }
  onDestroy() {
    this._navigationCleanup?.();
  }
  onAttributeChange(e, t, r) {
    e === "href" ? (this.href = r, this.updateAnchorHref(), this.updateActiveState()) : e === "active-class" && (this.activeClass = r, this.updateActiveState());
  }
  onPropertyChange(e) {
    (e === "href" || e === "queryParams") && (this.updateAnchorHref(), this.updateActiveState());
  }
  isActive() {
    const e = window.location.pathname, t = this.href.startsWith("/") ? this.href : `/${this.href}`;
    return this.exactMatch ? e === t : e.startsWith(t);
  }
  buildFullPath() {
    let e = this.href;
    if (this.queryParams && Object.keys(this.queryParams).length > 0) {
      const t = new URLSearchParams(this.queryParams);
      e = `${e}?${t.toString()}`;
    }
    return e;
  }
  updateAnchorHref() {
    this._anchorElement && (this._anchorElement.href = this.buildFullPath());
  }
  async navigate() {
    const e = {
      data: this.data,
      replace: this.replace,
      queryParams: this.queryParams
    };
    await this._router.navigate(this.href, e);
  }
  updateActiveState() {
    const e = window.location.pathname, t = this.href.startsWith("/") ? this.href : `/${this.href}`, r = e.replace(/\/$/, "") || "/", s = t.replace(/\/$/, "") || "/";
    let o;
    this.exactMatch ? o = r === s : o = r === s || r.startsWith(s + "/"), o ? (this.elementRef.classList.add(this.activeClass), this._anchorElement?.setAttribute("aria-current", "page")) : (this.elementRef.classList.remove(this.activeClass), this._anchorElement?.removeAttribute("aria-current"));
  }
};
x([T(S), k("design:type", typeof (pe = typeof S < "u" && S) == "function" ? pe : Object)], U.prototype, "_router", void 0);
U = x([be({
  selector: "router-link",
  template: () => ne`<a part="link"><slot></slot></a>`,
  styles: () => Ye`
		:host {
			display: inline-block;
			cursor: pointer;
		}
		a {
			color: inherit;
			text-decoration: inherit;
			font: inherit;
			display: block;
		}
	`,
  attributes: ["href", "active-class"]
})], U);
function et(n, e, t) {
  let r;
  if (typeof e == "string") r = { href: e };
  else if (e && typeof e == "object" && "href" in e) r = e;
  else {
    console.warn("routerLink: Invalid value. Expected string or { href: string, ... }");
    return;
  }
  const { href: s, activeClass: o = "active", exactMatch: i = !1, replace: a = !1, data: c = null, queryParams: h = {} } = r, u = P.get(S), d = () => {
    let _ = s;
    if (h && Object.keys(h).length > 0) {
      const p = new URLSearchParams(h);
      _ = `${_}?${p.toString()}`;
    }
    return _;
  };
  n.tagName.toLowerCase() === "a" && (n.href = d());
  const l = () => {
    const _ = window.location.pathname, p = s.startsWith("/") ? s : `/${s}`, m = _.replace(/\/$/, "") || "/", b = p.replace(/\/$/, "") || "/";
    let g;
    i ? g = m === b : g = m === b || m.startsWith(b + "/"), g ? (n.classList.add(o), n.tagName.toLowerCase() === "a" && n.setAttribute("aria-current", "page")) : (n.classList.remove(o), n.removeAttribute("aria-current")), n.setAttribute("router-link", "");
  }, f = (_) => {
    const p = _;
    if (p.ctrlKey || p.metaKey || p.shiftKey) {
      if (n.tagName.toLowerCase() === "a") return;
      window.open(d(), "_blank");
      return;
    }
    _.preventDefault();
    const m = {
      data: c,
      replace: a,
      queryParams: h
    };
    u.navigate(s, m);
  }, y = () => {
    l();
  };
  return n.addEventListener("click", f), window.addEventListener("NavigationEvent", y), l(), (() => {
    n.removeEventListener("click", f), window.removeEventListener("NavigationEvent", y);
  });
}
Me("routerLink", et);
var ke = null;
const me = (n) => {
  ke = n;
}, Ae = () => ke;
var tt = class {
  constructor(n) {
    this.execute = n, this._dependencies = /* @__PURE__ */ new Set(), this._isRunning = !1, this._needsRerun = !1, this.run = () => {
      if (this._isRunning) {
        this._needsRerun = !0;
        return;
      }
      this._isRunning = !0;
      do {
        this._needsRerun = !1, this._dependencies.forEach((t) => {
          t.unsubscribe(this.run);
        }), this._dependencies.clear();
        const e = Ae();
        me(this), this.execute(), me(e);
      } while (this._needsRerun);
      this._isRunning = !1;
    };
  }
  addDependency(n) {
    this._dependencies.add(n);
  }
  destroy() {
    this._dependencies.forEach((n) => {
      n.unsubscribe(this.run);
    }), this._dependencies.clear();
  }
};
function re(n) {
  let e = n;
  const t = /* @__PURE__ */ new Set(), r = () => {
    [...t].forEach((o) => o(e));
  }, s = (() => {
    const o = Ae();
    return o && (o.addDependency(s), t.add(o.run)), e;
  });
  return s.set = (o) => {
    e !== o && (e = o, r());
  }, s.update = (o) => {
    s.set(o(e));
  }, s.subscribe = (o) => (t.add(o), () => t.delete(o)), s.unsubscribe = (o) => {
    t.delete(o);
  }, s.destroy = () => {
    t.clear();
  }, Object.defineProperty(s, we, {
    value: !0,
    enumerable: !1,
    configurable: !1
  }), s;
}
function Ne(n) {
  const e = re(void 0), t = new tt(() => {
    e.set(n());
  });
  t.run();
  const r = e.destroy;
  return e.destroy = () => {
    t.destroy(), r();
  }, e;
}
const Mt = () => () => ({}), kt = (n, e) => ((t) => ({
  type: n,
  payload: t ?? (e ? e() : void 0)
}));
function At(...n) {
  return { reducers: n };
}
const Nt = (n) => {
  const e = {};
  return Object.keys(n).forEach((t) => {
    e[t] = re(n[t]);
  }), e;
}, Tt = (n, e) => ({
  action: n(),
  reducer: e
}), z = j("RX_INIT_STATE"), X = j("RX_ACTION_PROVIDERS"), J = j("RX_EFFECTS_PROVIDERS"), Te = j("RX_STATE_DEBUG");
var nt = class {
  constructor() {
    this._effects = [];
  }
  addEffect(n, e) {
    this._effects.push({
      actions: n,
      effect: e
    });
  }
  getEffects() {
    return this._effects;
  }
}, It = class extends nt {
  constructor(n, e = { reducers: [] }, t = !1) {
    super(), this._initState = n, this._reducerConfig = e, this._debug = t, this._state = re(n);
  }
  get state() {
    return this._state();
  }
  resetState() {
    this._state.set(this._initState);
  }
  select(n) {
    return Ne(() => n(this._state()));
  }
  dispatch(n) {
    this._debug && (console.log(`[ComponentState] Action: ${n.type}`), console.log("[ComponentState] Payload:", n.payload), console.log("[ComponentState] Before:", this._state()));
    const e = this._reducerConfig.reducers.find((t) => t.action.type === n.type);
    e && (this._state.update((t) => e.reducer(t, n)), this._debug && console.log("[ComponentState] After:", this._state())), this.executeEffects(n);
  }
  patchState(n) {
    this._state.update((e) => ({
      ...e,
      ...n
    }));
  }
  executeEffects(n) {
    this.getEffects().filter((e) => e.actions.some((t) => t().type === n.type)).forEach((e) => {
      e.effect(n).then((t) => {
        t !== void 0 && (Array.isArray(t) ? t : [t]).forEach((r) => this.dispatch(r));
      });
    });
  }
}, M = class {
  constructor() {
    this._debug && console.info("RX State Debugging: Enabled");
  }
  select(e, t) {
    return Ne(() => t(this._state[e]()));
  }
  logState() {
    console.log(this.getCurrentState());
  }
  dispatch(e, t) {
    const r = typeof e == "string" ? e : void 0, s = typeof e == "string" ? t : e;
    this._debug && (console.log(`Action: ${s.type}`), console.log("Payload:", s.payload), console.log("Current State:", this.getCurrentState())), r ? this.dispatchWithKey(r, s) : this.dispatchWithoutKey(s);
  }
  dispatchWithKey(e, t) {
    if (!this._reducerMap[e]) throw new Error(`Reducer not found for key: ${e}`);
    const r = this._reducerMap[e].reducers.find((s) => s.action.type === t.type);
    if (r !== void 0) {
      const s = r.reducer(this._state[e](), t);
      this._state[e].set(s), this._debug && console.log("New State:", this.getCurrentState());
    }
    this.getEffectsForAction(e, t).forEach((s) => {
      s.effect(t).then((o) => {
        o !== void 0 && (Array.isArray(o) || (o = [o]), o.forEach((i) => {
          this.dispatch(i);
        }));
      });
    });
  }
  dispatchWithoutKey(e) {
    const t = this.getReducerForAction(e);
    if (t !== void 0) {
      const s = t.actionReducer.reducer(this._state[t.key](), e);
      this._state[t.key].set(s), this._debug && console.log("New State:", this.getCurrentState());
    }
    const r = this.getEffectsForAction(e);
    r !== void 0 && r.actionEffects.forEach((s) => {
      s.effect(e).then((o) => {
        o !== void 0 && (Array.isArray(o) || (o = [o]), o.forEach((i) => {
          this.dispatch(i);
        }));
      });
    });
  }
  getReducerForAction(e) {
    const t = Object.keys(this._reducerMap);
    for (const r of t) {
      const s = (this._reducerMap[r]?.reducers || []).find((o) => o.action.type === e.type);
      if (s) return {
        key: r,
        actionReducer: s
      };
    }
  }
  getEffectsForAction(e, t) {
    return typeof e == "string" ? this.getEffectsForActionWithKey(e, t) : this.getEffectsForActionWithoutKey(e);
  }
  getEffectsForActionWithoutKey(e) {
    const t = Object.keys(this._reducerMap);
    for (const r of t) {
      const s = this._effectMap[r];
      if (s) {
        const o = P.get(s).getEffects().filter((i) => i.actions.some((a) => a().type === e.type));
        if (o.length > 0) return {
          key: r,
          actionEffects: o
        };
      }
    }
  }
  getEffectsForActionWithKey(e, t) {
    const r = this._effectMap[e];
    return r ? P.get(r).getEffects().filter((s) => s.actions.some((o) => o().type === t.type)) : [];
  }
  getCurrentState() {
    return Object.keys(this._state).reduce((e, t) => (e[t] = this._state[t](), e), {});
  }
};
x([T(z), k("design:type", Object)], M.prototype, "_state", void 0);
x([T(X), k("design:type", Object)], M.prototype, "_reducerMap", void 0);
x([T(J), k("design:type", Object)], M.prototype, "_effectMap", void 0);
x([T(Te), k("design:type", Boolean)], M.prototype, "_debug", void 0);
M = x([Q(), k("design:paramtypes", [])], M);
function Ot(n, e, t, r = !1) {
  return (s) => {
    s.bindValue(z, n), s.bindValue(X, e), s.bindValue(J, t), s.bindValue(Te, r), s.bind(M, M, { dependencies: [
      z,
      X,
      J
    ] });
  };
}
var ge = /* @__PURE__ */ new WeakMap(), rt = class Ie {
  constructor(e) {
    this._factory = null, this._hasEvents = !1, this._canCompile = !1, this.analyzeAndCompile(e);
  }
  static compile(e) {
    let t = ge.get(e);
    return t || (t = new Ie(e), ge.set(e, t)), t;
  }
  /**
  * Check if this template can use the fast path
  */
  canUseFastPath() {
    return this._canCompile && !this._hasEvents;
  }
  /**
  * Create DOM nodes using the compiled factory
  */
  create(e) {
    return this._factory ? {
      nodes: [this._factory(e)],
      eventTargets: []
    } : {
      nodes: [],
      eventTargets: []
    };
  }
  /**
  * Directly create a single node - faster than create() for single-element templates
  */
  createDirect(e) {
    return this._factory ? this._factory(e) : null;
  }
  /**
  * Analyze template and generate optimized factory for simple cases
  *
  * Template strings format for: html`<li class="${val}">${text}</li>`
  * strings = ['<li class="', '">', '</li>']
  * values[0] goes between strings[0] and strings[1]
  * values[1] goes between strings[1] and strings[2]
  */
  analyzeAndCompile(e) {
    if (e.length < 2) return;
    for (const m of e) if (m.includes("@")) {
      this._hasEvents = !0;
      return;
    }
    let t = e[0];
    for (let m = 1; m < e.length; m++) t += `\${${m - 1}}` + e[m];
    const r = t.match(/^<([\w-]+)([^>]*)>(.*)$/s);
    if (!r) return;
    const [, s, o, i] = r, a = `</${s}>`;
    if (!i.endsWith(a)) return;
    const c = i.slice(0, -a.length), h = [], u = /([\w-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|\$\{(\d+)\})/g;
    let d;
    for (; (d = u.exec(o)) !== null; ) {
      const m = d[1], b = d[2] ?? d[3], g = d[4];
      if (g !== void 0) h.push({
        name: m,
        valueIndex: parseInt(g, 10)
      });
      else if (b !== void 0) {
        const w = b.match(/\$\{(\d+)\}/);
        w ? h.push({
          name: m,
          valueIndex: parseInt(w[1], 10)
        }) : h.push({
          name: m,
          valueIndex: null,
          staticValue: b
        });
      }
    }
    const l = [], f = c, y = /\$\{(\d+)\}/g;
    let _ = 0, p;
    for (y.lastIndex = 0; (p = y.exec(f)) !== null; )
      p.index > _ && l.push({ static: f.slice(_, p.index) }), l.push({ valueIndex: parseInt(p[1], 10) }), _ = p.index + p[0].length;
    _ < f.length && l.push({ static: f.slice(_) }), this._factory = (m) => {
      const b = document.createElement(s);
      for (const w of h) if (w.valueIndex !== null) {
        const v = m[w.valueIndex];
        v != null && v !== !1 && b.setAttribute(w.name, v === !0 ? "" : String(v));
      } else w.staticValue !== void 0 && b.setAttribute(w.name, w.staticValue);
      let g = "";
      for (const w of l) "static" in w ? g += w.static : g += m[w.valueIndex] ?? "";
      return b.textContent = g, b;
    }, this._canCompile = !0;
  }
};
function I(n) {
  return {
    __directive: !0,
    render: n
  };
}
function Dt(n, e, t) {
  return I((r, s) => {
    if (!s) {
      const o = r.parentNode;
      if (!o) throw new Error("repeat() directive: container must be attached to a parent node");
      const i = document.createComment("repeat-start"), a = document.createComment("repeat-end");
      o.replaceChild(i, r), o.insertBefore(a, i.nextSibling);
      const c = {
        keyToIndex: /* @__PURE__ */ new Map(),
        items: [],
        startMarker: i,
        endMarker: a
      };
      return _e(n, e, t, c), c;
    }
    return _e(n, e, t, s), s;
  });
}
function _e(n, e, t, r) {
  const s = r.items, o = /* @__PURE__ */ new Map(), i = [];
  for (let l = 0; l < n.length; l++) {
    const f = e(n[l], l);
    o.set(f, l);
  }
  if (s.length === n.length) {
    let l = !0;
    for (let f = 0; f < n.length; f++) {
      const y = e(n[f], f);
      if (f >= s.length || s[f].key !== y) {
        l = !1;
        break;
      }
    }
    if (l) {
      for (let f = 0; f < n.length; f++) t(n[f], f).renderInto(s[f].container);
      return;
    }
  }
  if (r.useCompiledPath === void 0 && n.length > 0) {
    const l = t(n[0], 0), f = rt.compile(l.strings);
    r.useCompiledPath = f.canUseFastPath(), r.useCompiledPath && (r.compiledTemplate = f);
  }
  const a = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
  for (const l of s)
    a.set(l.key, l), c.set(l.key, c.size);
  for (let l = 0; l < n.length; l++) {
    const f = n[l], y = e(f, l);
    if (a.has(y)) {
      const _ = a.get(y);
      a.delete(y), t(f, l).renderInto(_.container), i.push({
        item: _,
        oldIndex: c.get(y) ?? -1,
        isNew: !1
      });
    } else {
      const _ = st(f, l, y, t, r);
      i.push({
        item: _,
        oldIndex: -1,
        isNew: !0
      });
    }
  }
  for (const l of a.values()) at(l);
  if (i.length === 0) {
    r.keyToIndex = o, r.items = [];
    return;
  }
  const h = ct(i), u = r.startMarker.parentElement;
  let d = r.endMarker;
  for (let l = i.length - 1; l >= 0; l--) {
    const f = i[l];
    f.isNew ? ot(f.item, u, d) : h.has(l) || it(f.item, d), d = f.item.start;
  }
  r.keyToIndex = o, r.items = i.map((l) => l.item);
}
function st(n, e, t, r, s) {
  const o = r(n, e);
  let i, a;
  if (s.useCompiledPath && s.compiledTemplate) {
    const c = s.compiledTemplate.createDirect(o.values);
    c ? (i = [c], a = document.createDocumentFragment(), a.appendChild(c)) : (a = document.createDocumentFragment(), i = o.renderOnce(a));
  } else
    a = document.createDocumentFragment(), i = o.renderOnce(a);
  return {
    key: t,
    value: n,
    container: a,
    nodes: i,
    start: document.createComment("repeat-item-start"),
    end: document.createComment("repeat-item-end")
  };
}
function ot(n, e, t) {
  const r = document.createDocumentFragment();
  r.appendChild(n.start);
  for (const s of n.nodes) r.appendChild(s);
  r.appendChild(n.end), e.insertBefore(r, t);
}
function it(n, e) {
  const t = e.parentNode;
  if (!t) return;
  const r = document.createDocumentFragment();
  let s = n.start;
  const o = n.end;
  for (; s; ) {
    const i = s.nextSibling;
    if (r.appendChild(s), s === o) break;
    s = i;
  }
  t.insertBefore(r, e);
}
function at(n) {
  let e = n.start;
  const t = n.end;
  for (; e; ) {
    const r = e.nextSibling;
    if (e.parentNode?.removeChild(e), e === t) break;
    e = r;
  }
}
function ct(n) {
  const e = [], t = [];
  for (let o = 0; o < n.length; o++) n[o].oldIndex >= 0 && (e.push(n[o].oldIndex), t.push(o));
  const r = lt(e), s = /* @__PURE__ */ new Set();
  for (const o of r) {
    const i = t[o];
    i !== void 0 && s.add(i);
  }
  return s;
}
function lt(n) {
  if (n.length === 0) return [];
  const e = new Array(n.length).fill(-1), t = new Array(n.length).fill(0);
  let r = 0;
  for (let i = 0; i < n.length; i++) {
    const a = n[i];
    let c = 0, h = r;
    for (; c < h; ) {
      const u = c + h >> 1;
      n[t[u]] < a ? c = u + 1 : h = u;
    }
    c > 0 && (e[i] = t[c - 1]), t[c] = i, c === r && r++;
  }
  const s = new Array(r);
  let o = t[r - 1];
  for (let i = r - 1; i >= 0; i--)
    s[i] = o, o = e[o];
  return s;
}
function qt(n, e, t) {
  return I((r, s) => {
    if (!s) {
      const o = r.parentNode;
      if (!o) throw new Error("repeatRaw() directive: container must be attached to a parent node");
      const i = document.createComment("repeat-raw-start"), a = document.createComment("repeat-raw-end");
      o.replaceChild(i, r), o.insertBefore(a, i.nextSibling);
      const c = {
        keyToItem: /* @__PURE__ */ new Map(),
        startMarker: i,
        endMarker: a
      }, h = document.createDocumentFragment();
      for (let u = 0; u < n.length; u++) {
        const d = n[u], l = e(d, u), f = t(d, u);
        c.keyToItem.set(l, {
          key: l,
          element: f
        }), h.appendChild(f);
      }
      return o.insertBefore(h, a), c;
    }
    return ht(n, e, t, s), s;
  });
}
function ht(n, e, t, r) {
  const s = r.keyToItem, o = /* @__PURE__ */ new Map(), i = r.startMarker.parentElement, a = r.endMarker;
  if (s.size === n.length) {
    let u = !0, d = 0;
    for (const [l] of s) {
      if (l !== e(n[d], d)) {
        u = !1;
        break;
      }
      d++;
    }
    if (u) {
      d = 0;
      for (const [l, { element: f }] of s) {
        const y = n[d], _ = t(y, d);
        f !== _ ? (f.replaceWith(_), o.set(l, {
          key: l,
          element: _
        })) : o.set(l, {
          key: l,
          element: f
        }), d++;
      }
      r.keyToItem = o;
      return;
    }
  }
  const c = document.createDocumentFragment(), h = /* @__PURE__ */ new Set();
  for (let u = 0; u < n.length; u++) {
    const d = n[u], l = e(d, u);
    h.add(l);
    const f = s.get(l);
    if (f) {
      const y = t(d, u);
      f.element !== y ? (o.set(l, {
        key: l,
        element: y
      }), c.appendChild(y)) : (o.set(l, f), c.appendChild(f.element));
    } else {
      const y = t(d, u);
      o.set(l, {
        key: l,
        element: y
      }), c.appendChild(y);
    }
  }
  for (const [u, { element: d }] of s) h.has(u) || d.remove();
  i.insertBefore(c, a), r.keyToItem = o;
}
function Lt(n, e, t) {
  return I((r, s) => {
    if (!s) {
      const o = r.parentNode;
      if (!o) throw new Error("when() directive: container must be attached to a parent node");
      const i = document.createComment("when-start"), a = document.createComment("when-end");
      o.replaceChild(i, r), o.insertBefore(a, i.nextSibling);
      const c = {
        condition: !1,
        template: e(),
        falseTemplate: t ? t() : null,
        container: null,
        startMarker: i,
        endMarker: a,
        nodes: []
      };
      return n ? L(c, !0) : c.falseTemplate && L(c, !1), c.condition = n, c;
    }
    if (!s.startMarker.parentNode) throw new Error("when() directive: markers were removed from DOM");
    if (n && !s.condition)
      ye(s), s.template = e(), L(s, !0);
    else if (!n && s.condition)
      ye(s), t && (s.falseTemplate = t(), L(s, !1));
    else if (n && s.condition) {
      const o = e();
      s.container && o.renderInto(s.container), s.template = o;
    } else if (!n && !s.condition && t) {
      const o = t();
      s.container && o.renderInto(s.container), s.falseTemplate = o;
    }
    return s.condition = n, s;
  });
}
function L(n, e) {
  const t = n.startMarker.parentNode;
  if (!t) throw new Error("when() directive: markers not in DOM");
  const r = e ? n.template : n.falseTemplate;
  if (!r) return;
  const s = document.createDocumentFragment();
  r.renderInto(s), n.container = s, n.nodes = Array.from(s.childNodes);
  for (const o of n.nodes) t.insertBefore(o, n.endMarker);
}
function ye(n) {
  for (const e of n.nodes) e.parentNode?.removeChild(e);
  n.nodes = [], n.container = null;
}
function jt(n) {
  return I((e, t) => {
    const r = e, s = /* @__PURE__ */ new Set();
    for (const [o, i] of Object.entries(n)) i && (r.classList.add(o), s.add(o));
    if (t)
      for (const o of t) s.has(o) || r.classList.remove(o);
    return s;
  });
}
function Bt(n) {
  return I((e, t) => {
    const r = e, s = /* @__PURE__ */ new Set();
    for (const [o, i] of Object.entries(n)) i !== void 0 && (r.style.setProperty(o.replace(/([A-Z])/g, "-$1").toLowerCase(), String(i)), s.add(o));
    if (t)
      for (const o of t) s.has(o) || r.style.removeProperty(o.replace(/([A-Z])/g, "-$1").toLowerCase());
    return s;
  });
}
function Ft(n) {
  return I((e, t) => {
    if (!t) {
      const r = e.parentNode;
      if (!r) throw new Error("unsafeHTML() directive: container must be attached to a parent node");
      const s = document.createComment("unsafeHTML-start"), o = document.createComment("unsafeHTML-end");
      r.replaceChild(s, e), r.insertBefore(o, s.nextSibling);
      const i = {
        html: "",
        startMarker: s,
        endMarker: o,
        nodes: []
      };
      return ve(n, i), i;
    }
    return t.html === n || ve(n, t), t;
  });
}
function ve(n, e) {
  const t = e.startMarker.parentNode;
  if (!t) throw new Error("unsafeHTML() directive: markers not in DOM");
  for (const o of e.nodes) o.parentNode?.removeChild(o);
  const r = document.createElement("div");
  r.innerHTML = n;
  const s = document.createDocumentFragment();
  for (; r.firstChild; ) s.appendChild(r.firstChild);
  e.nodes = Array.from(s.childNodes);
  for (const o of e.nodes) t.insertBefore(o, e.endMarker);
  e.html = n;
}
function ut(n) {
  return typeof n == "string" ? document.querySelector(n) : n;
}
function dt(n) {
  return typeof n == "string" ? {
    target: n,
    persist: !1
  } : n instanceof Element ? {
    target: n,
    persist: !1
  } : {
    target: n.target,
    persist: n.persist ?? !1
  };
}
function ft(n, e, t) {
  if (!e) {
    console.warn("portal directive: value is required");
    return;
  }
  const r = dt(e), s = ut(r.target);
  if (!s) {
    console.warn(`portal directive: target "${r.target}" not found`);
    return;
  }
  if (n.parentNode === s) return;
  const o = document.createComment("portal-placeholder");
  return n.parentNode?.insertBefore(o, n), n.removeAttribute(":portal"), s.appendChild(n), () => {
    r.persist || n.remove(), o.remove();
  };
}
Me("portal", ft);
var Kt = class {
  constructor() {
    this.__directive = !0;
  }
};
export {
  He as AbortError,
  F as Binding,
  Be as ComponentBase,
  It as ComponentStateBaseService,
  Kt as Directive,
  nt as EffectsBase,
  Y as HttpBaseError,
  ce as HttpClient,
  Fe as HttpError,
  pt as Inject,
  Q as Injectable,
  $e as InjectionEngine,
  P as Injector,
  be as MelodicComponent,
  Ke as NetworkError,
  We as ROUTE_CONTEXT_EVENT,
  X as RX_ACTION_PROVIDERS,
  J as RX_EFFECTS_PROVIDERS,
  z as RX_INIT_STATE,
  Te as RX_STATE_DEBUG,
  wt as RouteContextEvent,
  W as RouteContextService,
  H as RouteMatcher,
  U as RouterLinkComponent,
  G as RouterOutletComponent,
  S as RouterService,
  we as SIGNAL_MARKER,
  T as Service,
  tt as SignalEffect,
  M as SignalStoreService,
  Ze as TemplateResult,
  qe as applyGlobalStyles,
  mt as bootstrap,
  Ue as buildPathFromRoute,
  jt as classMap,
  Ne as computed,
  kt as createAction,
  yt as createDeactivateGuard,
  _t as createGuard,
  At as createReducer,
  vt as createResolver,
  Nt as createState,
  j as createToken,
  Ye as css,
  I as directive,
  Ge as findRouteByName,
  Ae as getActiveEffect,
  Je as getAttributeDirective,
  Et as getRegisteredDirectives,
  E as getTokenKey,
  Rt as hasAttributeDirective,
  ne as html,
  D as isDirective,
  Oe as isSignal,
  V as matchRouteTree,
  Tt as onAction,
  ft as portalDirective,
  Mt as props,
  gt as provideHttp,
  Ot as provideRX,
  Me as registerAttributeDirective,
  se as render,
  Dt as repeat,
  qt as repeatRaw,
  et as routerLinkDirective,
  me as setActiveEffect,
  re as signal,
  Bt as styleMap,
  xt as unregisterAttributeDirective,
  Ft as unsafeHTML,
  Lt as when
};
